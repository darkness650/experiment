\documentclass[12pt]{article}
\usepackage{ctex}
\usepackage{setspace}
\usepackage{graphicx}
%opening
\doublespacing
\title{bm算法与kmp算法的性能比较实验报告}
\author{2311269 孙威旺 }

\begin{document}
\maketitle
\begin{center}
	原始数据：https://github.com/darkness650/experiment/tree/main/datastruct
\end{center}
\begin{Large}
	\heiti
	 一.算法说明：
\end{Large}
\zihao{4}

KMP算法：KMP算法的主要思想是避免检索字符串时在主串中的字符回溯，而
是通过已经匹配的部分来调整回溯模式串，而主串指针不断向后进行。而回溯模式串
应该回溯的位数则通过next数组确定，next数组是一个与主串无关，只与模式串有
关的数组，它里面所存放的数据即当某一位出现匹配错误时应该回溯到的位置。例如
串“abcacdab”，如果在加粗的 c 处出现了匹配错误，那模式串就应该回溯到[1]的位置，
即第二个字符b开始匹配。当回溯到模式串头后任无法匹配成功，则向后移动比较下
一位，通过这种方式避免对主串的回溯，大幅减少匹配的次数，使效率更高。而next
数组内的含义则是，在第【i】个数据前的真前缀与真后缀重叠的长度。任然以上述例
子，加粗的c以前的重叠的只有a，即加粗的c以前的a已经和主串对应了，那么再
进行回溯的时候不需要从头开始，回溯到b这个位置即可，因为开头ab中，a已经
确认是符合的了，直接检验b和主串是否对应即可。 

BM算法：BM算法规定了两个原则，即好后缀原则与坏字符原则。坏字符原则即
为，在逆向比对字符串时，若出现失配，则在模式串中找失配的主串的字符，这个字
符为坏字符。若没有这个字符，那么整个模式串右移到主串指针的下一位。若有这个
字符，就将主串中的字符与此时模式串最右边的字符对齐。好后缀原则即为，在逆向
对比字符串时，已经匹配过的子串即为好后缀，在出现失配后，在模式串中寻找字串
出现过最右端的位置，跳到那个位置再从最后开始逆向比对即可。利用这两个规则可
以跳过很多不必要的对比，从而加快比对速度，减少对比次数，来提高对比效率。

\begin{Large}
	{\noindent
		\heiti
二.算法核心 } 
\end{Large}

\zihao{4}
KMP算法中，关键就在于求出模式串对应的next数组，即每个字符匹配出错时
应该回溯的位置。现假设next【i】=k，意思就是p[0]p[1]…p[k-1]与p[i-k]p[i
k+1]…p[i-1]是相同的，加入 p[i]也等于 p[k]，那么显然 next[i+1]=k+1，假如不匹配，
那么依据上述next的意义，应该将p[k]回溯到p[next[k]]，判断是否与p[i]相等。重
复上述步骤。令next[0]=-1，即是标记模式串的头，也是便于后面出现头也不相匹
配时++，且这样得到的数可以直接用于访问数组下标。而KMP算法也可以进一步
优化，即优化next数组，假如p[k]与p[next[k]]是一样的，那么回溯后一定也是失配
的，需要再次回溯，所以出现这种情况，可以让next[k]=next[next[k]]来避免。 

BM算法中，关键就是利用好后缀原则与坏字符原则，不难发现，好后缀原则
里，通过好后缀的跳跃类似于KMP算法的next数组，与主串无关，只与模式串有
关。例如在abdabcab中，c处匹配出错，则ab，b均为好后缀，于是在c的前面寻
找，则模式串向后移动三位，让c前的ab与之前匹配成功的ab对齐，再从末尾开
始匹配。因为这种匹配模式是倒着匹配，所以为了找到对应的数组，可以先确定SS
数组，即在[0,i]区域内与[0,n-1]相同的后缀的字符个数，记录给 SS[i]，他的意思就是，
从i往前数SS[i]个数，这SS[i]个数是与模式串后的SS[i]个数是对应的，若在第i个
数出现了失配，那么就可以根据SS数组来判断应该移动几位。把移动的位数存在
GS 数组中，如果SS[i]=k，那么就是说，当前的这个数往前的一共k个数，与模式
串的后k个数相同，那么在回溯的时候，在[0,n-1-k]之间失配的话，指针向后移动
n-k 位一定是可行的，但是不一定是最安全的，按照这种方法每个计入GS的值，取
最小值。例如101011010中，SS对应为{020400209}，所以在[0,4]失配的时候，向
后移动9-4=5一定是可行的。再假设在[6]处失配，即第七个数，现在已经匹配了两
个数，而[6]与[1]对应的都是2，则应该移动8-6=2位，而不是8-1=7，这样移动的
更安全。如果从SS数组中去寻找对应规律，设SS[i]=k，那么在第n-k个失配的时
候，GS[n-k-1]应该等于n-1-i，即最后一个数到这个数的距离。使得移动更安全。 

坏字符原则。在模式串与主串匹配时，匹配不上的主串的那个字符即为坏字符。
然后从模式串所在的位置向前寻找坏字符，出现坏字符后将这两个坏字符对应在一起，
接着向后匹配。若没有出现坏字符，那么需要将整个模式串移动到当前指针的后方，
再进行匹配。可以发现坏字符原则移动的位置是与主串有关的。然后对比好后缀与坏
字符的到的跳跃步数，选取更多的那个来跳跃。 

在对比测试时间的时候，我用的是QueryPerformanceCounter来记录时刻，得到
毫秒级别的时间准确度。


	


	\includegraphics[width=\linewidth]{"C:/Users/the dark/Pictures/Screenshots/屏幕截图 2024-10-25 232718.png"}
\begin{center}{ \zihao{5}  kmp算法流程图}
\end{center}

	


	\includegraphics[width=\linewidth]{"C:/Users/the dark/Pictures/Screenshots/屏幕截图 2024-10-25 234400.png"}
\begin{center}{ \zihao{5}  bm算法流程图}
\end{center}
	


\begin{large}
	\noindent
	\heiti
	三.数据分析
\end{large}

附件中的原始数据表是将文首的github地址上存储的所有数据整理下来，求时间平均数。而平均性能表的sheet1是平均时间性能，单位为毫秒，sheet2是平均比较次数性能。由于某种原因，平均次数只测了每个组别的第一组数据，但我认为其仍然可以说明以下的问题：

github上的数据中，对于主串来说，（单位：字符）短：20，中：500，长：2000，超长：4096（本来准备了10000长的数据，但由于string一次最多只能输入4096故超长串只有4096）
对于模式串来说，短：10以内，中：200以内，长：400以内，超长：800以上，最大1000多。

01组：主串和模式串全为0和1组成。

数字组：主串和模式串均由0到9的数字组成。

字符组：主串和模式串均由大于空格ASCII码的字符组成。

\begin{figure}[h]
	
	\centering
	\includegraphics[width=\linewidth]{"C:/Users/the dark/Pictures/Screenshots/屏幕截图 2024-10-25 170718.png"}
	\caption{时间性能表}
	\label{fig:enter-label}
	
\end{figure}

在该表中可以看出，BM算法在除主串中无模式串且主串为长串或者超长串的情况下从运行时间上来说被kmp算法全面击败，但这真的是因为bm算法本身不行吗？

\begin{figure}[h]
	
	\centering
	\includegraphics[width=\linewidth]{"C:/Users/the dark/Pictures/Screenshots/屏幕截图 2024-10-25 170705.png"}
	\caption{比较次数性能表}
	\label{fig:enter-label}
	
\end{figure}

在该表中我们可以看到，BM算法在每一项测试用例上的比较次数均小于kmp算法，在超长主串，超长模式串，主串中无模式串的情况下竟然可以以个位数的比较次数结束搜索，这说明在移动模式串的速度上，BM算法要优于kmp算法，然而数字组超长主串超长模式串的模式串全0情况下，BM算法的比较次数仅为个位数，kmp算法的比较次数超过8000，但BM算法竟然慢到了38ms，与kmp算法的运行时间0.2532ms相比慢了150倍。

究其原因，bm算法构建ss数组时的m的平方数量级的时间复杂度是bm算法在运行时间上几乎全面落败于kmp算法的主要原因，尤其是在全0串这样的构建上体现得尤为明显，因为全0串会让bm算法构建ss数组时完全达到m平方数量级的时间复杂度，而其他情况则可能由于模式串子串在最后一个字符就与模式串的最后一个字符不符导致直接终止循环，最好情况下复杂度为m的数量级，这也就是bm算法在模式串为完全混乱的在主串中无匹配的情况下运行时间会优胜的重要原因。

综合来看，bm算法在长主串的搜索中的跳跃速度极快，而kmp算法在这方面较为疲软，但在数据量较小的情况下（即使是该文中的超长串也依然属于数据量小的情况），bm算法的跳跃优势无法完全施展出来，因为bm算法构建ss串的速度赶不上kmp算法跳跃的速度，用句通俗的话来说：或许在bm算法还在构建ss串的时候kmp算法就已经跳跃完毕了。但若是将主串的长度变得非常长，那么这时字符串的“跳跃”速度就会变成两者比较的主要矛盾，尤其是在模式串并不是非常长的时候（这样会让bm算法构建ss串的劣势降到最低）。

其次，在比较次数表中可知，模式串越是在主串的后面，bm算法越占优势，若模式串在主串前面，kmp算法与bm算法的比较次数实际上相差不大，由此，我总结出bm算法占优的四个条件。

1.主串的数据量极大的时候。

2.模式串的数据量不大（相较于主串来说不大即可）的时候。

3.模式串的位置在主串的后面，甚至不在主串中的时候。

4.在模式串和主串中都有很多种类的字符的时候

在上述情况下，bm算法的ss串构建劣势将被缩到最小，且跳跃速度的优势被发挥到极大。

\begin{large}
	\noindent
	\heiti
	四.反思总结
\end{large}

1.bm算法有上述的三个条件的约束完全是因为它ss数组那m平方级的时间复杂度太过于高，在面对长模式串的时候这个劣势会变得无比致命，若是能找到一种线性时间复杂度的构建ss数组的方法，那么bm算法将会几乎全面优于kmp算法（当然，在短串等情况下依然不行，因为bm算法不仅要构造ss数组，还要构造gs数组和坏字符数组，而kmp算法只需要构造next数组），但这样的话在现实情况里，bm算法劣势的情况就会变得极为稀少，导致其拥有很高的泛用性

2.若bm算法只采用坏字符策略，从理论上说，它很可能在模式串和主串中有很多类型的字符的时候全方位超过kmp算法，因为在有很多种类字符的时候坏字符策略发挥的效能最高，同时没有了构建ss数组和gs数组的时间耗费，在坏字符策略与kmp算法都只构建一个数组的时候坏字符策略极有可能占据绝对优势

3.当然，kmp算法也有自己的优势区间，模式串在主串前，模式串中有重复部分的字串很多等时候kmp算法都会更优一些，但是若是bm算法解决了ss数组的问题，这部分的优势区间也会被bm算法挤占，导致kmp算法只在极少数情况下占优，想必这也是kmp算法在工业上无用武之地的原因

4.考虑到现实情况里的数据库主串的数量级可能会非常庞大，而模式串相比来说可能只是一些关键词之类的比较小的数量级，导致bm算法在实际情况下与如此测出来的情况并不相同，即现实情况中的情况大多属于bm算法的优势区间（只与kmp算法相比）

\begin{large}
	\noindent
	\heiti
	五.测试用代码
\end{large}

详见github：https://github.com/darkness650/experiment\newline
/tree/main/datastruct
\end{document}
